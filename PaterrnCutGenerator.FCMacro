# -*- coding: utf-8 -*- 
""" 
Pattern HOLES (planar) - v0.9 (PL/ENG version) 
FreeCAD 1.0.2

""" 

import FreeCAD as App 
import FreeCADGui as Gui 
import Part 
from PySide import QtGui, QtCore 
import math 
import urllib.request
import io

VERSION = "0.9"
PREVIEW_OBJ_NAME = "Pattern_Preview_Phantom" 
PARAM_PATH = "User parameter:BaseApp/Preferences/Macros/PatternHoles"
pattern_macro_window = None 
TRANSLATIONS = {
    "EN": {
        "macro_title": "Pattern Cut Generator",
        "welcome_title": "Pattern Cut Generator - Introduction",
        "welcome_text": "Welcome to the macro for generating patterns on flat surfaces.<br><br><b>How to use:</b><br>1. Select a <b>flat face</b> in 3D view.<br>2. Click <b>'Get selected face'</b>.<br>3. Choose shape, size, and gap.<br>4. Click <b>'GENERATE CUT'</b>.<br><br><i>The macro stays open for further editing.</i>",
        "dont_show": "Don't show this window again",
        "start_work": "Start working",
        "sel_face_btn": "Get selected face",
        "sel_done": "Selected: ",
        "preview_on": "Preview: ON",
        "preview_off": "Preview: OFF",
        "shape": "Shape:",
        "size": "Size:",
        "gap": "Gap:",
        "border": "Border:",
        "horiz": "Slotted horizontal",
        "depth": "Depth:",
        "run": "GENERATE CUT",
        "close": "Close Macro",
        "shapes": ["Hexagons", "Circles", "Diamonds", "Slotted", "Triangles"],
        "picking": "Select face...",
        "proc": "Processing...",
        "help_title": "Introduction / Help",
        "help_warning": "<br><b style='color:#ff5555;'>WARNING:</b> Generating on large surfaces can heavily tax your CPU. The program may appear frozen, but <b>do not close it</b> – it is working in the background.",
        "author_header": "Author:",
        "github": "https://github.com/mjakubowskilkr/freecad-macros",
        "btn_help": "Help / Info",
        "lbl_shape": "Pattern parameters",
        "help_desc": "<b>How to use:</b><br>1. Select a flat face in 3D.<br>2. Click 'Select Target Face'.<br>3. Adjust parameters.<br>4. Click GENERATE CUT.",
        "elements": "Elements: ",
        "progress": "Progress: ",
        "ready": "Ready to generate",
        "border_err": "Error: Border too large!",
        "show_at_startup": "Show this window at startup"
    },
    "PL": {
        "macro_title": "Generator Wycięć Wzorów",
        "welcome_title": "Generator Wycięć Wzorów - Wprowadzenie",
        "welcome_text": "Witaj w makrze do generowania wzorów na płaskich powierzchniach.<br><br><b>Jak używać:</b><br>1. Zaznacz <b>płaską ścianę</b> w widoku 3D.<br>2. Kliknij <b>'Pobierz zaznaczoną ścianę'</b>.<br>3. Wybierz kształt i dostosuj rozmiar oraz odstępy.<br>4. Kliknij <b>'GENERUJ WYCIĘCIE'</b>.<br><br><i>Makro pozostaje otwarte, abyś mógł edytować kolejne ściany.</i>",
        "dont_show": "Nie wyświetlaj więcej tego okna",
        "start_work": "Rozpocznij pracę",
        "sel_face_btn": "Pobierz zaznaczoną ścianę",
        "sel_done": "Wybrano: ",
        "preview_on": "Podgląd: WŁĄCZONY",
        "preview_off": "Podgląd: WYŁĄCZONY",
        "shape": "Kształt:",
        "size": "Rozmiar:",
        "gap": "Odstęp (Gap):",
        "border": "Ramka:",
        "horiz": "Fasolki poziomo",
        "depth": "Głębokość:",
        "run": "GENERUJ WYCIĘCIE",
        "close": "Zamknij Makro",
        "shapes": ["Heksagony", "Okręgi", "Romby", "Fasolki", "Trójkąty"],
        "picking": "Wybierz ścianę...",
        "proc": "Przetwarzanie...",
        "help_title": "Wprowadzenie / Pomoc",
        "help_warning": "<br><b style='color:#ff5555;'>UWAGA:</b> Generowanie na dużych powierzchniach może mocno obciążyć komputer. Program może wyglądać na zawieszony, ale <b>nie należy go zamykać</b> – pracuje w tle.",
        "author_header": "Autor:",
        "github": "https://github.com/mjakubowskilkr/freecad-macros",
        "btn_help": "Pomoc / Info",
        "lbl_shape": "Parametry wzoru",
        "help_desc": "<b>Jak używać:</b><br>1. Zaznacz płaską ścianę w 3D.<br>2. Kliknij 'Pobierz zaznaczoną ścianę'.<br>3. Dostosuj parametry.<br>4. Kliknij GENERUJ WYCIĘCIE.",
        "elements": "Elementy: ",
        "progress": "Postęp: ",
        "ready": "Gotowy do generowania",
        "border_err": "Błąd: Za duża ramka!",
        "show_at_startup": "Pokazuj to okno przy starcie"
    }
}
def get_flag_online(lang):
    """Pobiera flagę z sieci. W przypadku błędu/offline zwraca pustą ikonę."""
    # Mapowanie na kody ISO dla FlagCDN (UK -> gb)
    code = "pl" if lang == "PL" else "gb"
    url = f"https://flagcdn.com/w40/{code}.png"
    
    try:
        # Timeout 0.5s, żeby nie mrozić UI przy braku sieci
        with urllib.request.urlopen(url, timeout=0.5) as response:
            data = response.read()
            pixmap = QtGui.QPixmap()
            if pixmap.loadFromData(data):
                return QtGui.QIcon(pixmap)
    except:
        pass
    return QtGui.QIcon() # Zwraca pustą ikonę (wyzwoli tekst w UI)
    
def make_face_from_shape(shape): 
    try: 
        if shape.ShapeType == 'Face': return shape
        if shape.ShapeType == 'Wire': return Part.Face(shape)
        if shape.ShapeType == 'Edge': return Part.Face(Part.Wire([shape]))
        return None
    except: return None 

class WelcomeDialog(QtGui.QDialog):
    def __init__(self, lang="EN", is_startup=True, parent=None):
        super(WelcomeDialog, self).__init__(parent)
        self.lang = lang
        self.is_startup = is_startup 
        self.setWindowFlags(self.windowFlags() | QtCore.Qt.WindowStaysOnTopHint)
        self.init_ui()

    def init_ui(self):
        # Pełne czyszczenie layoutu przy przełączaniu języków
        if self.layout() is not None:
            old_layout = self.layout()
            while old_layout.count():
                item = old_layout.takeAt(0)
                if item.widget(): 
                    item.widget().deleteLater()
            QtGui.QWidget().setLayout(old_layout)
            
        t = TRANSLATIONS[self.lang]
        self.setWindowTitle("Info" if self.is_startup else t["help_title"])
        self.setMinimumWidth(500)
        self.setStyleSheet("QWidget { background-color: #333333; color: #e0e0e0; font-size: 11pt; }")
        
        layout = QtGui.QVBoxLayout(self)
        layout.setContentsMargins(30, 20, 30, 20)

        # PASEK JĘZYKÓW (z ikonami)
        lang_bar = QtGui.QHBoxLayout()
        lang_bar.addStretch()
        for code in ["PL", "EN"]:
            btn = QtGui.QPushButton()
            icon_obj = get_flag_online(code)
            if not icon_obj.isNull():
                btn.setIcon(icon_obj)
                btn.setIconSize(QtCore.QSize(30, 18))
            else:
                btn.setText(code)
            btn.setFixedSize(55, 35)
            btn.setFlat(True)
            color = "#4CAF50" if self.lang == code else "#888888"
            btn.setStyleSheet(f"font-weight: bold; color: {color}; border: 1px solid {color}; border-radius: 4px;")
            btn.clicked.connect(lambda *args, c=code: self.change_lang(c))
            lang_bar.addWidget(btn)
        lang_bar.addStretch()
        layout.addLayout(lang_bar)

        # Treść nagłówka
        title = QtGui.QLabel(f"<div style='text-align: center;'><b style='color: #4CAF50; font-size: 16pt;'>{t['macro_title']}</b><br>v{VERSION}</div>")
        layout.addWidget(title)
        
        # Opis i ostrzeżenie
        desc = QtGui.QLabel(t["help_desc"] + "<br><br>" + t["help_warning"])
        desc.setWordWrap(True)
        desc.setAlignment(QtCore.Qt.AlignCenter)
        layout.addWidget(desc)
        
        # INICJALIZACJA CHECKBOXA
        params = App.ParamGet(PARAM_PATH)
        self.chk_welcome = QtGui.QCheckBox()
        
        if self.is_startup:
            self.chk_welcome.setText(t["dont_show"])
            self.chk_welcome.setChecked(False)
        else:
            self.chk_welcome.setText(t["show_at_startup"])
            self.chk_welcome.setChecked(params.GetBool("ShowWelcome", True))
            # W trybie pomocy zapisujemy od razu po kliknięciu
            self.chk_welcome.stateChanged.connect(lambda state: params.SetBool("ShowWelcome", bool(state)))
            
        layout.addWidget(self.chk_welcome)
        
        # PRZYCISKI DOLNE
        if self.is_startup:
            self.btn_ok = QtGui.QPushButton(t["start_work"])
            self.btn_ok.setFixedHeight(40)
            self.btn_ok.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border-radius: 4px;")
            self.btn_ok.clicked.connect(self.accept)
            layout.addWidget(self.btn_ok)
        else:
            self.btn_close = QtGui.QPushButton(t["close"])
            self.btn_close.setFixedHeight(40)
            self.btn_close.setStyleSheet("background-color: #555555; color: white; border-radius: 4px;")
            self.btn_close.clicked.connect(self.accept)
            layout.addWidget(self.btn_close)

    def change_lang(self, new_lang):
        self.lang = new_lang
        self.init_ui() # Przebuduj okno w nowym języku

    def set_lang(self, lang):
        self.lang = lang
        self.retranslate()

    def retranslate(self):
        t = TRANSLATIONS[self.lang]
        self.setWindowTitle("{} v{} [{}]".format(t["macro_title"], VERSION, self.lang))
        
        # Etykiety parametrów
        self.lbl_shape.setText(t["shape"])
        self.lbl_size.setText(t["size"])
        self.lbl_gap.setText(t["gap"])
        self.lbl_border.setText(t["border"])
        self.lbl_depth.setText(t["depth"])
        
        # Grupy i przyciski
        if hasattr(self, 'gb_sel'): self.gb_sel.setTitle(f"1. {t['sel_face_btn']}")
        self.btn_sel.setText(t["sel_face_btn"] if not self.target_face else f"{t['sel_done']}{self.target_object.Label}")
        self.btn_preview_toggle.setText(t["preview_on"] if self.preview_enabled else t["preview_off"])
        self.btn_run.setText(t["run"])
        self.btn_close.setText(t["close"])
        self.btn_help_call.setText(t["btn_help"])
        self.chk_horizontal.setText(t["horiz"])
        
        # Status - TO TUTAJ BYŁ "DUCH"
        if hasattr(self, 'lbl_status'):
            if self.target_face is None:
                self.lbl_status.setText(t["ready"])
            else:
                self.lbl_status.setText(f"{t['elements']}{self.last_count}")

        # ComboBox
        self.combo_type.blockSignals(True)
        curr_idx = self.combo_type.currentIndex()
        self.combo_type.clear()
        self.combo_type.addItems(t["shapes"])
        self.combo_type.setCurrentIndex(curr_idx if curr_idx >= 0 else 0)
        self.combo_type.blockSignals(False)

    def is_checked(self):
        return self.chk_welcome.isChecked()

class PatternHolesPanel(QtGui.QWidget): 

    def switch_language(self, lang_code):
        self.lang = lang_code
        t = TRANSLATIONS[self.lang]
        
        # 1. Aktualizacja obramowania przycisków flag
        for code, btn in self.lang_buttons.items():
            color = "#4CAF50" if self.lang == code else "transparent"
            btn.setStyleSheet(f"border: 2px solid {color}; border-radius: 4px; padding: 2px;")
            
        # 2. Wywołanie zbiorczego tłumaczenia kontrolek
        self.retranslate()

    def show_help_dialog(self, is_startup=False):
        dlg = WelcomeDialog(self.lang, is_startup=is_startup, parent=self) 
        dlg.exec_()
    
    def set_lang(self, lang):
        self.lang = lang
        self.retranslate()
        
    def __init__(self): 
        
        super(PatternHolesPanel, self).__init__() 
        fc_lang = str(App.ParamGet("User parameter:BaseApp/Preferences/Editor").GetString("Language"))
        self.lang = "PL" if fc_lang == "Polish" else "EN"
        self.lang_buttons = {} 
        self.last_count = 0 # Przechowuje liczbę elementów do tłumaczenia
        
        self.target_face = None 
        self.target_object = None 
        self.origin = None; self.u = None; self.v = None; self.n = None 
        self.preview_enabled = True 

        self.preview_timer = QtCore.QTimer() 
        self.preview_timer.setSingleShot(True) 
        self.preview_timer.setInterval(150) 
        self.preview_timer.timeout.connect(self.update_preview_geometry) 

        self.blink_timer = QtCore.QTimer() 
        self.blink_timer.setInterval(100) 
        self.blink_timer.timeout.connect(self.blink_button_tick) 
        self.blink_counter = 0 

        self.setStyleSheet(""" 
            QWidget { background-color: #333333; color: #e0e0e0; font-family: sans-serif; font-size: 14px; } 
            QGroupBox { border: 1px solid #555555; margin-top: 10px; border-radius: 4px; padding-top: 15px; } 
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding: 0 5px; color: #4CAF50; background-color: #333333; } 
            QPushButton { border: 1px solid #666666; padding: 6px; border-radius: 4px; color: #ffffff; background-color: #444444; } 
            QPushButton:hover { border-color: #4CAF50; } 
            QComboBox, QDoubleSpinBox, QCheckBox { background-color: #222222; border: 1px solid #555555; padding: 4px; color: #ffffff; } 
        """) 

        self.initUI() 
        self.load_settings() # DODANO: Wczytaj zapisane parametry
        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint) 
        
    def save_settings(self):
        """Zapisuje parametry do rejestru FreeCAD."""
        p = App.ParamGet(PARAM_PATH)
        p.SetInt("ShapeIdx", self.combo_type.currentIndex())
        p.SetFloat("Size", self.sb_size.value())
        p.SetFloat("Gap", self.sb_gap.value())
        p.SetFloat("Border", self.sb_border.value())
        p.SetFloat("Depth", self.sb_depth.value())
        p.SetBool("Horizontal", self.chk_horizontal.isChecked())

    def load_settings(self):
        """Wczytuje parametry z rejestru FreeCAD."""
        p = App.ParamGet(PARAM_PATH)
        # Używamy setValue, aby nie wyzwalać update_preview przedwcześnie, 
        # dlatego blokujemy sygnały na moment ładowania.
        self.blockSignals(True)
        try:
            if p.GetFloat("Size") != 0.0: # Sprawdzenie czy klucze istnieją
                self.combo_type.setCurrentIndex(p.GetInt("ShapeIdx", 0))
                self.sb_size.setValue(p.GetFloat("Size", 5.0))
                self.sb_gap.setValue(p.GetFloat("Gap", 1.0))
                self.sb_border.setValue(p.GetFloat("Border", 3.0))
                self.sb_depth.setValue(p.GetFloat("Depth", 3.0))
                self.chk_horizontal.setChecked(p.GetBool("Horizontal", True))
        except: pass
        self.blockSignals(False)

    def closeEvent(self, event):
        # 1. Zapisz ustawienia użytkownika
        self.save_settings()
        
        # 2. ZATRZYMAJ WSZYSTKIE TIMERY (zabicie "duchów" w tle)
        if hasattr(self, 'preview_timer'):
            self.preview_timer.stop()
        if hasattr(self, 'blink_timer'):
            self.blink_timer.stop()
            
        # 3. Usuń obiekt podglądu z drzewa dokumentu
        self.remove_preview_object()
        
        # 4. UWOLNIJ PAMIĘĆ FREECADA (Kluczowe dla błędu Access Violation)
        self.target_face = None
        self.target_object = None
        self.origin = None
        self.u = None
        self.v = None
        self.n = None
        
        # 5. Całkowicie zniszcz obiekt okna w PySide
        self.deleteLater()
        event.accept()
        
    def initUI(self): 
        t = TRANSLATIONS[self.lang]
        # Budowanie tytułu ze słownika, zmiennej VERSION i skrótu języka
        self.setWindowTitle("{} v{} [{}]".format(t["macro_title"], VERSION, self.lang))
        self.setMinimumWidth(400)
        
        # 1. NAJPIERW tworzymy główny layout
        self.main_layout = QtGui.QVBoxLayout(self)

        # 2. POTEM tworzymy pasek flag i pomocy
        top_bar = QtGui.QHBoxLayout()
        # Fragment paska flag w PatternHolesPanel:
        for code in ["PL", "EN"]:
            btn = QtGui.QPushButton()
            icon_obj = get_flag_online(code)
            if not icon_obj.isNull():
                btn.setIcon(icon_obj)
                btn.setIconSize(QtCore.QSize(32, 20)) # Powiększone
            else:
                btn.setText(code)
            btn.setFixedSize(45, 35) # Powiększone
            btn.setFlat(True)
            btn.clicked.connect(lambda *args, c=code: self.switch_language(c))
            top_bar.addWidget(btn)
            self.lang_buttons[code] = btn # Rejestracja
        
        top_bar.addStretch()
        # Przycisk pomocy
        self.btn_help_call = QtGui.QPushButton(t["btn_help"])
        self.btn_help_call.setStyleSheet("background-color: #555555; font-size: 10px;")
        self.btn_help_call.clicked.connect(lambda: self.show_help_dialog(is_startup=False))
        top_bar.addWidget(self.btn_help_call)
        
        # 3. TERAZ dodajemy top_bar do głównego layoutu
        self.main_layout.addLayout(top_bar)
        
        gb_sel = QtGui.QGroupBox("1. Wybór ściany") 
        sel_layout = QtGui.QVBoxLayout() 
        self.btn_sel = QtGui.QPushButton("Pobierz zaznaczoną ścianę") 
        self.btn_sel.setFixedHeight(40) 
        self.btn_sel.clicked.connect(self.start_selection_blink) 
        sel_layout.addWidget(self.btn_sel) 
        gb_sel.setLayout(sel_layout) 
        self.main_layout.addWidget(gb_sel) 

        self.btn_preview_toggle = QtGui.QPushButton("Podgląd: WŁĄCZONY") 
        self.btn_preview_toggle.setFixedHeight(30) 
        self.btn_preview_toggle.setStyleSheet("background-color: #2e7d32; font-weight: bold;") 
        self.btn_preview_toggle.clicked.connect(self.toggle_preview_state) 
        self.main_layout.addWidget(self.btn_preview_toggle) 

        gb_pat = QtGui.QGroupBox("3. Parametry wzoru") 
        grid = QtGui.QGridLayout() 
        
        def make_spin(val): 
            sb = QtGui.QDoubleSpinBox() 
            sb.setRange(0.01, 1000.0); sb.setValue(val); sb.setSingleStep(0.5); sb.setSuffix(" mm") 
            sb.valueChanged.connect(self.trigger_update) 
            return sb 
            
        self.combo_type = QtGui.QComboBox() 
        self.combo_type.addItems(["Heksagony", "Kwadraty", "Okręgi", "Romby", "Fasolki", "Trójkąty"]) 
        self.combo_type.currentIndexChanged.connect(self.trigger_update) 
        
        # Inicjalizacja Kształtu
        self.lbl_shape = QtGui.QLabel("")
        self.combo_type = QtGui.QComboBox()
        self.combo_type.addItems(["", "", "", "", "", ""]) # Miejsca na tłumaczenia
        self.combo_type.currentIndexChanged.connect(self.trigger_update)

        # Inicjalizacja Rozmiaru, Odstępu, Ramki
        self.lbl_size = QtGui.QLabel("")
        self.sb_size = make_spin(5.0)

        self.lbl_gap = QtGui.QLabel("")
        self.sb_gap = make_spin(1.0)

        self.lbl_border = QtGui.QLabel("")
        self.sb_border = make_spin(3.0)

        # Inicjalizacja Fasolek (zgodnie z Twoją uwagą)
        self.chk_horizontal = QtGui.QCheckBox("") 
        self.chk_horizontal.setChecked(True)
        self.chk_horizontal.stateChanged.connect(self.trigger_update)

        # Układanie w grid (zmienne już istnieją)
        grid.addWidget(self.lbl_shape, 0, 0)
        grid.addWidget(self.combo_type, 0, 1)
        grid.addWidget(self.lbl_size, 1, 0)
        grid.addWidget(self.sb_size, 1, 1)
        grid.addWidget(self.lbl_gap, 2, 0)
        grid.addWidget(self.sb_gap, 2, 1)
        grid.addWidget(self.lbl_border, 3, 0)
        grid.addWidget(self.sb_border, 3, 1)
        grid.addWidget(self.chk_horizontal, 4, 1)
        
        self.lbl_status = QtGui.QLabel(t["ready"])
        self.lbl_status.setStyleSheet("color: #aaa; font-size: 11px;")
        self.main_layout.addWidget(self.lbl_status)

        self.progress_bar = QtGui.QProgressBar()
        self.progress_bar.setFixedHeight(12)
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setStyleSheet("QProgressBar { border: 1px solid #555; background: #222; } QProgressBar::chunk { background: #4CAF50; }")
        self.progress_bar.setValue(0)
        self.main_layout.addWidget(self.progress_bar)

        btn_box = QtGui.QHBoxLayout() 
        self.btn_run = QtGui.QPushButton(t["run"]) 
        self.btn_run.setFixedHeight(45) 
        self.btn_run.setEnabled(False) # DOMYŚLNIE WYŁĄCZONY
        self.btn_run.setStyleSheet("QPushButton:disabled { background-color: #555; color: #888; } QPushButton:enabled { background-color: #d32f2f; font-weight: bold; color: white; }")

        gb_pat.setLayout(grid)
        self.main_layout.addWidget(gb_pat) 
        
        gb_op = QtGui.QGroupBox("4. Wykonanie") 
        op_layout = QtGui.QGridLayout() 
        self.sb_depth = make_spin(3.0) 
        self.lbl_depth = QtGui.QLabel("")
        op_layout.addWidget(self.lbl_depth, 0, 0)
        op_layout.addWidget(self.sb_depth, 0, 1)
        gb_op.setLayout(op_layout) 
        self.main_layout.addWidget(gb_op) 

        btn_box = QtGui.QHBoxLayout() 
        self.btn_run = QtGui.QPushButton(t["run"]) 
        self.btn_run.setFixedHeight(45) 
        self.btn_run.setStyleSheet("background-color: #d32f2f; font-weight: bold; color: white;") 
        self.btn_run.clicked.connect(self.run_generation) 
        
        self.btn_close = QtGui.QPushButton(t["close"]) # Zmieniono z "Zamknij Makro"
        self.btn_close.setFixedHeight(45) 
        self.btn_close.clicked.connect(self.close) 

        btn_box.addWidget(self.btn_run); btn_box.addWidget(self.btn_close) 
        self.main_layout.addLayout(btn_box) 
        self.main_layout.addStretch() 
        self.retranslate()

    def start_selection_blink(self): 
        self.blink_counter = 0; self.blink_timer.start() 

    def blink_button_tick(self): 
        self.blink_counter += 1 
        self.btn_sel.setStyleSheet("background-color: #2196F3;" if self.blink_counter % 2 else "") 
        if self.blink_counter >= 4: 
            self.blink_timer.stop(); self.get_selection() 

    def get_selection(self):
        t = TRANSLATIONS[self.lang]
        if self.target_face is not None:
            self.target_face = None
            self.target_object = None
            self.remove_preview_object()
            self.btn_sel.setText(t["sel_face_btn"])
            self.btn_sel.setStyleSheet("")
            self.btn_run.setEnabled(False)
            self.lbl_status.setText(t["ready"]) # ZMIANA: brak "Ready to generate"
            self.last_count = 0
            Gui.Selection.clearSelection()
            self.btn_run.setEnabled(False) # Wyłącz jeśli skasowano wybór
            return

        # LOGIKA WYBORU: (Twoja oryginalna, sprawdzona wersja)
        self.btn_sel.setText(t["picking"])
        sel = Gui.Selection.getSelectionEx()
        if not sel: return
        target = sel[-1]
        if not target.SubObjects or not isinstance(target.SubObjects[-1], Part.Face): return
        f = target.SubObjects[-1]
        try:
            self.n = f.normalAt(0,0); self.n.normalize()
            self.origin = f.CenterOfMass
            ref = App.Vector(1,0,0) if abs(self.n.dot(App.Vector(1,0,0))) < 0.9 else App.Vector(0,1,0)
            self.u = ref.cross(self.n); self.u.normalize()
            self.v = self.n.cross(self.u); self.v.normalize()
            
            self.target_face = f
            self.target_object = target.Object
            self.btn_run.setEnabled(True) # WŁĄCZ PO WYBORZE
            
            self.btn_sel.setText(f"{t['sel_done']}: {self.target_object.Label}")
            self.btn_sel.setStyleSheet("background-color: #43A047; font-weight: bold;")
            Gui.Selection.clearSelection()
            self.trigger_update()
        except: pass

    def generate_pattern_shapes(self, idx, xmin, xmax, ymin, ymax, d, gap): 
        out = [] 
        is_horiz = self.chk_horizontal.isChecked() 
        
        # Współczynnik dla równego odstępu w trójkątach (1/sqrt(3))
        inv_sqrt3 = 0.57735
        
        # 1. PARAMETRY SIATKI
        if idx == 0: sy = d + gap; sx = sy * 0.866025 # zmiana w poziom
        elif idx == 1: 
            sx = d + gap; sy = (d + gap) * 0.866025
        elif idx == 2: # Diamenty
            sx = d + gap; sy = d / 2.0 + gap
        elif idx == 3: # Fasolki (Slotted)
            w = d * 0.4
            # ODWRÓCONA LOGIKA: 
            # Jeśli zaznaczone (Horizontal) -> sx (poziom) ma być długi, sy (pion) krótki
            if is_horiz:
                sx = d + gap
                sy = w + gap
            else:
                sx = w + gap
                sy = d + gap
        elif idx == 4: # TRÓJKĄTY (Gęsty mesh rzędowy - Opcja A)
            h = d * 0.866025
            # Skok poziomy: połowa podstawy + gap
            sx = (d / 2.0) + (gap / 0.866025) 
            # Skok pionowy: pełna wysokość + gap
            sy = h + gap
        else: 
            sx = sy = d + gap
        
        cols, rows = int((xmax-xmin)/sx)+8, int((ymax-ymin)/sy)+8
        
        for r in range(-4, rows): 
            for c in range(-4, cols): 
                cx, cy = xmin + c*sx, ymin + r*sy 
                
                # 2. LOGIKA PRZESUNIĘCIA (ZGODNIE Z TWOIM WZOREM)
                if idx == 0:
                    # HEX -> Przesunięcie KOLUMNOWE (pionowe), żeby Flat Top wszedł w siebie w poziomie
                    if c % 2 == 1: 
                        cy += sy / 2.0
                elif idx == 3 and not is_horiz:
                    # FASOLKI PIONOWE -> Układ KOLUMNOWY
                    if c % 2 == 1: 
                        cy += sy / 2.0
                elif idx in [1, 2] or (idx == 3 and is_horiz):
                    # KOŁO, ROMB, FASOLKI POZIOME -> Układ RZĘDOWY (poziomy)
                    if r % 2 == 1: 
                        cx += sx / 2.0
                
                # 3. RYSOWANIE
                if idx == 0: # HEX (Pointy Top)
                    rad = d / math.sqrt(3)
                    pts = [App.Vector(cx + rad*math.cos(a), cy + rad*math.sin(a), 0) for a in [math.radians(60*i) for i in range(7)]]
                    out.append(Part.makePolygon(pts))
                elif idx == 1: # CIRCLE
                    out.append(Part.makeCircle(d/2.0, App.Vector(cx, cy, 0)))
                elif idx == 2: # DIAMOND
                    h = d / 2.0
                    out.append(Part.makePolygon([App.Vector(cx,cy-h,0), App.Vector(cx+h,cy,0), App.Vector(cx,cy+h,0), App.Vector(cx-h,cy,0), App.Vector(cx,cy-h,0)]))
                elif idx == 3: # SLOTTED (Fasolki)
                    w = d * 0.4; r_s = w / 2.0; l = (d - w) / 2.0
                    if not is_horiz: 
                        # RYSOWANIE POZIOME (linie na osi X)
                        e1 = Part.makeLine(App.Vector(cx-l, cy+r_s, 0), App.Vector(cx+l, cy+r_s, 0))
                        e2 = Part.Arc(App.Vector(cx+l, cy+r_s, 0), App.Vector(cx+l+r_s, cy, 0), App.Vector(cx+l, cy-r_s, 0)).toShape()
                        e3 = Part.makeLine(App.Vector(cx+l, cy-r_s, 0), App.Vector(cx-l, cy-r_s, 0))
                        e4 = Part.Arc(App.Vector(cx-l, cy-r_s, 0), App.Vector(cx-l-r_s, cy, 0), App.Vector(cx-l, cy+r_s, 0)).toShape()
                    else: 
                        # RYSOWANIE PIONOWE (linie na osi Y)
                        e1 = Part.Arc(App.Vector(cx-r_s, cy+l, 0), App.Vector(cx, cy+l+r_s, 0), App.Vector(cx+r_s, cy+l, 0)).toShape()
                        e2 = Part.makeLine(App.Vector(cx+r_s, cy+l, 0), App.Vector(cx+r_s, cy-l, 0))
                        e3 = Part.Arc(App.Vector(cx+r_s, cy-l, 0), App.Vector(cx, cy-l-r_s, 0), App.Vector(cx-r_s, cy-l, 0)).toShape()
                        e4 = Part.makeLine(App.Vector(cx-r_s, cy-l, 0), App.Vector(cx-r_s, cy+l, 0))
                    out.append(Part.Wire([e1, e2, e3, e4]))
                elif idx == 4: # TRIANGLE (Naprzemienne w rzędzie - Interlock)
                    h = d * 0.866025
                    half_h = h / 2.0
                    
                    # (r + c) % 2 sprawia, że sąsiadujące trójkąty są obrócone
                    if (r + c) % 2 == 0:
                        # Delta (Góra)
                        pts = [App.Vector(cx, cy + half_h, 0), 
                               App.Vector(cx + d/2.0, cy - half_h, 0), 
                               App.Vector(cx - d/2.0, cy - half_h, 0)]
                    else:
                        # Nabla (Dół)
                        pts = [App.Vector(cx, cy - half_h, 0), 
                               App.Vector(cx - d/2.0, cy + half_h, 0), 
                               App.Vector(cx + d/2.0, cy + half_h, 0)]
                    out.append(Part.makePolygon(pts + [pts[0]]))
        return out
        
    def set_ui_enabled(self, state):
        """Włącza lub wyłącza kontrolki interfejsu."""
        widgets = [
            self.btn_sel, 
            self.btn_preview_toggle, 
            self.sb_size, 
            self.sb_gap, 
            self.sb_border, 
            self.sb_depth, 
            self.combo_type, 
            self.chk_horizontal,
            self.btn_close
        ]
        for w in widgets:
            w.setEnabled(state)

# --- MIEJSCE WSTAWIENIA: Metoda get_final_compound ---
# --- ZMIANA: Przejście na operację zbiorczą (Compound-to-Face Common) ---

    def get_final_compound(self, work_face):
        idx = self.combo_type.currentIndex()
        xs, ys = [], []
        for vtx in work_face.Vertexes:
            vec = vtx.Point.sub(self.origin)
            xs.append(vec.dot(self.u)); ys.append(vec.dot(self.v))
        
        xmin, xmax, ymin, ymax = min(xs), max(xs), min(ys), max(ys)
        
        # Generowanie surowych kształtów
        raw = self.generate_pattern_shapes(idx, xmin, xmax, ymin, ymax, self.sb_size.value(), self.sb_gap.value())
        pl = App.Placement(self.origin, App.Rotation(self.u, self.v, self.n))
        
        # 1. Tworzymy listę wszystkich ścian otworów bez wycinania ich
        all_hole_faces = []
        for s in raw:
            f = make_face_from_shape(s)
            if f:
                f.Placement = pl
                all_hole_faces.append(f)
        
        if not all_hole_faces: return None

        # 2. Łączymy wszystko w jeden Compound
        big_compound = Part.makeCompound(all_hole_faces)
        
        # 3. WYDAJNOŚĆ: Jedna operacja common zamiast setek/tysięcy
        try:
            # Operacja common na Compoundzie automatycznie zwróci Compound wyciętych fragmentów
            final_result = big_compound.common(work_face)
            
            # Sprawdzenie czy cokolwiek zostało (powierzchnia > 0)
            if hasattr(final_result, "Area") and final_result.Area > 0:
                return final_result
            return None
        except:
            return None

    def trigger_update(self): 
        if self.preview_enabled and self.target_face: self.preview_timer.start() 

    def toggle_preview_state(self): 
        t = TRANSLATIONS[self.lang]
        self.preview_enabled = not self.preview_enabled 
        
        # Ustawiamy tekst na podstawie stanu i języka
        new_text = t["preview_on"] if self.preview_enabled else t["preview_off"]
        self.btn_preview_toggle.setText(new_text) 
        
        # Opcjonalnie: zmiana koloru, żeby było widać status na pierwszy rzut oka
        if self.preview_enabled:
            self.btn_preview_toggle.setStyleSheet("background-color: #2e7d32; font-weight: bold;")
            self.trigger_update()
        else:
            self.btn_preview_toggle.setStyleSheet("background-color: #444444; font-weight: normal;")
            self.remove_preview_object()

    def remove_preview_object(self): 
        doc = App.ActiveDocument
        if not doc: return
        
        # Pobieramy nazwy wszystkich obiektów podglądu (obsługa indeksów 001, 002...)
        obs_to_del = [o.Name for o in doc.Objects if PREVIEW_OBJ_NAME in o.Name or PREVIEW_OBJ_NAME in o.Label]
        
        if obs_to_del:
            for n in obs_to_del:
                try: 
                    doc.removeObject(n)
                except: 
                    pass
            # Bezpieczne odświeżanie bez generowania AttributeError
            doc.recompute()
            Gui.updateGui()

    def update_preview_geometry(self): 
        if not App.ActiveDocument or not self.target_face or not self.preview_enabled: return 
        t = TRANSLATIONS[self.lang]
        self.remove_preview_object() 
        try:
            border = self.sb_border.value()
            try:
                if border > 0:
                    off_shape = self.target_face.makeOffset2D(-border)
                    if not off_shape.Faces: raise ValueError
                    work_face = off_shape.Faces[0]
                else:
                    work_face = self.target_face
            except:
                self.lbl_status.setText(f"<span style='color:#ff5555;'>{t['border_err']}</span>")
                return # Przerywamy podgląd jeśli ramka zjada całą ścianę
            
            # 1. Obliczanie liczby elementów
            idx = self.combo_type.currentIndex()
            xs, ys = [], []
            for vtx in work_face.Vertexes:
                vec = vtx.Point.sub(self.origin)
                xs.append(vec.dot(self.u)); ys.append(vec.dot(self.v))
            xmin, xmax, ymin, ymax = min(xs), max(xs), min(ys), max(ys)
            
            raw = self.generate_pattern_shapes(idx, xmin, xmax, ymin, ymax, self.sb_size.value(), self.sb_gap.value())
            self.last_count = len(raw)
            
            # 2. AKTUALIZACJA ETYKIETY (To tutaj brakowało odświeżenia!)
            self.lbl_status.setText(f"{t['elements']}{self.last_count}")

            # 3. Wyświetlanie podglądu (Compound)
            cp = self.get_final_compound(work_face)
            if cp:
                po = App.ActiveDocument.addObject("Part::Feature", PREVIEW_OBJ_NAME)
                po.Shape = cp.extrude(self.n.multiply(0.5)).fuse(cp.extrude(self.n.multiply(-0.5)))
                po.ViewObject.ShapeColor = (1.0, 0.0, 0.0)
                po.ViewObject.Transparency = 60
                App.ActiveDocument.recompute()
        except:
            pass

    def run_generation(self): 
        if not self.target_face: return 
        
        t = TRANSLATIONS[self.lang]
        self.set_ui_enabled(False)
        self.btn_run.setText(t["proc"])
        
        self.remove_preview_object() 
        doc = App.ActiveDocument 
        doc.openTransaction("PatternHoles") 
        try: 
            border, depth = self.sb_border.value(), self.sb_depth.value()
            self.n.normalize() 
            # --- WALIDACJA RAMKI PRZY GENEROWANIU ---
            try:
                work_face = self.target_face.makeOffset2D(-border).Faces[0] if border > 0 else self.target_face 
            except:
                QtGui.QMessageBox.warning(self, "Błąd", t["border_err"])
                self.set_ui_enabled(True)
                return 

            # 1. Obliczenia obszaru (xmin, xmax, ymin, ymax)
            xs, ys = [], []
            for vtx in work_face.Vertexes:
                vec = vtx.Point.sub(self.origin)
                xs.append(vec.dot(self.u)); ys.append(vec.dot(self.v))
            xmin, xmax, ymin, ymax = min(xs), max(xs), min(ys), max(ys)
            
            idx = self.combo_type.currentIndex()
            raw = self.generate_pattern_shapes(idx, xmin, xmax, ymin, ymax, self.sb_size.value(), self.sb_gap.value())
            
            total = len(raw)
            self.lbl_status.setText(f"{t['elements']}{total}")
            
            all_hole_faces = []
            pl = App.Placement(self.origin, App.Rotation(self.u, self.v, self.n))
            
            # 2. Budowanie geometrii otworów
            for i, s in enumerate(raw):
                if i % 20 == 0:
                    self.progress_bar.setValue(int((i / total) * 80))
                    QtGui.QApplication.processEvents()
                
                f = make_face_from_shape(s)
                if f:
                    f.Placement = pl
                    all_hole_faces.append(f)

            if all_hole_faces:
                self.lbl_status.setText(f"{t['elements']}{total} | {t['proc']}")
                big_compound = Part.makeCompound(all_hole_faces)
                self.progress_bar.setValue(90)
                QtGui.QApplication.processEvents()
                
                # --- KLUCZOWA POPRAWKA: Ograniczenie otworów do ramki work_face ---
                clipped_compound = big_compound.common(work_face)
                
                # Wycinamy tylko to, co mieści się w work_face (uwzględnia Border)
                cutter = clipped_compound.extrude(self.n.multiply(depth + 1.0)).fuse(clipped_compound.extrude(self.n.multiply(-(depth)))) 
                
                res = self.target_object.Shape.cut(cutter) 
                
                # Tworzenie obiektu w FreeCAD
                new_obj = doc.addObject("Part::Feature", "Patterned_" + self.target_object.Label) 
                new_obj.Shape = res
                self.target_object.Visibility = False 
                self.save_settings() # DODANO: Zapisz po udanej operacji
                doc.commitTransaction()
                doc.recompute()
                self.progress_bar.setValue(100)
            else:
                doc.abortTransaction()
                
        except Exception as e: 
            doc.abortTransaction()
            QtGui.QMessageBox.critical(self, "Błąd", str(e)) 
            
        finally:
            self.set_ui_enabled(True)
            self.btn_run.setEnabled(False) # Blokada po wykonaniu
            self.btn_run.setText(t["run"])
            self.lbl_status.setText(t["ready"])
            self.progress_bar.setValue(0)
            self.target_face = None # Reset wyboru
            self.btn_sel.setStyleSheet("")
            self.btn_sel.setText(t["sel_face_btn"])
            
    def retranslate(self):
        t = TRANSLATIONS[self.lang]
        
        # 1. Tytuł okna
        self.setWindowTitle("{} v{} [{}]".format(t["macro_title"], VERSION, self.lang))
        
        # 2. Etykiety parametrów (Pattern parameters)
        if hasattr(self, 'lbl_shape'): self.lbl_shape.setText(t["shape"])
        if hasattr(self, 'lbl_size'): self.lbl_size.setText(t["size"])
        if hasattr(self, 'lbl_gap'): self.lbl_gap.setText(t["gap"])
        if hasattr(self, 'lbl_border'): self.lbl_border.setText(t["border"])
        if hasattr(self, 'lbl_depth'): self.lbl_depth.setText(t["depth"])
        
        # 3. Status i Licznik (Dynamiczny napis)
        if hasattr(self, 'lbl_status'):
            if self.target_face is None:
                # Wymuszenie tłumaczenia: "Gotowy do generowania"
                self.lbl_status.setText(t["ready"])
            else:
                # Wymuszenie tłumaczenia: "Elementy: X"
                self.lbl_status.setText(f"{t['elements']}{self.last_count}")
        
        # 4. Przyciski i Checkboxy
        if hasattr(self, 'gb_sel'): self.gb_sel.setTitle(f"1. {t['sel_face_btn']}")
        self.btn_sel.setText(t["sel_face_btn"] if not self.target_face else f"{t['sel_done']}{self.target_object.Label}")
        self.btn_preview_toggle.setText(t["preview_on"] if self.preview_enabled else t["preview_off"])
        self.btn_run.setText(t["run"])
        self.btn_close.setText(t["close"])
        self.btn_help_call.setText(t["btn_help"])
        self.chk_horizontal.setText(t["horiz"])
        
        # 5. ComboBox (Aktualizacja listy kształtów)
        self.combo_type.blockSignals(True)
        curr_idx = self.combo_type.currentIndex()
        self.combo_type.clear()
        self.combo_type.addItems(t["shapes"])
        self.combo_type.setCurrentIndex(curr_idx if curr_idx >= 0 else 0)
        self.combo_type.blockSignals(False)        

def main():
    # Pobierz język z ustawień FreeCAD
    fc_lang = str(App.ParamGet("User parameter:BaseApp/Preferences/Editor").GetString("Language"))
    current_lang = "PL" if fc_lang == "Polish" else "EN"
    
    params = App.ParamGet(PARAM_PATH)
    
    # Obsługa okna startowego
    if params.GetBool("ShowWelcome", True):
        welcome = WelcomeDialog(current_lang, is_startup=True)
        # Jeśli użytkownik zamknie krzyżykiem przed kliknięciem Start, makro się nie uruchomi
        if not welcome.exec_():
            return
        
        # Zastosuj język wybrany w oknie powitalnym
        current_lang = welcome.lang
        
        # Jeśli zaznaczono 'Nie pokazuj więcej', zapisujemy False w ustawieniach
        if welcome.is_checked():
            params.SetBool("ShowWelcome", False)
    
    global pattern_macro_window
    pattern_macro_window = PatternHolesPanel()
    # Inicjalizacja języka i odświeżenie interfejsu
    pattern_macro_window.switch_language(current_lang)
    pattern_macro_window.show()

if __name__ == "__main__": 
    main()