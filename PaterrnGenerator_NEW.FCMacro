# -*- coding: utf-8 -*- 
""" 
Pattern HOLES (planar) - v0.3.19 (Welcome Screen & Persistent Settings) 
FreeCAD 1.0.2
""" 

import FreeCAD as App 
import FreeCADGui as Gui 
import Part 
from PySide import QtGui, QtCore 
import math 

PREVIEW_OBJ_NAME = "Pattern_Preview_Phantom" 
PARAM_PATH = "User parameter:BaseApp/Preferences/Macros/PatternHoles"
pattern_macro_window = None 

def make_face_from_shape(shape): 
    try: 
        if shape.ShapeType == 'Face': return shape
        if shape.ShapeType == 'Wire': return Part.Face(shape)
        if shape.ShapeType == 'Edge': return Part.Face(Part.Wire([shape]))
        return None
    except: return None 

class WelcomeDialog(QtGui.QDialog):
    def __init__(self):
        super(WelcomeDialog, self).__init__()
        self.setWindowTitle("Pattern Holes - Wprowadzenie")
        self.setMinimumWidth(400)
        self.setStyleSheet("background-color: #333333; color: #e0e0e0; font-family: sans-serif;")
        
        layout = QtGui.QVBoxLayout(self)
        
        title = QtGui.QLabel("<h2>Pattern Holes v0.3.19</h2>")
        title.setStyleSheet("color: #4CAF50;")
        layout.addWidget(title)
        
        desc = QtGui.QLabel(
            "Witaj w makrze do generowania wzorów na płaskich powierzchniach.<br><br>"
            "<b>Jak używać:</b><br>"
            "1. Zaznacz <b>płaską ścianę</b> na obiekcie w widoku 3D.<br>"
            "2. Kliknij <b>'Pobierz zaznaczoną ścianę'</b> w makrze.<br>"
            "3. Wybierz kształt i dostosuj rozmiar oraz odstępy (Gap).<br>"
            "4. Kliknij <b>'GENERUJ WYCIĘCIE'</b>.<br><br>"
            "<i>Makro pozostaje otwarte, abyś mógł edytować kolejne ściany.</i>"
        )
        desc.setWordWrap(True)
        layout.addWidget(desc)
        
        layout.addSpacing(20)
        
        self.chk_dont_show = QtGui.QCheckBox("Nie wyświetlaj więcej tego okna")
        layout.addWidget(self.chk_dont_show)
        
        btn_ok = QtGui.QPushButton("Rozpocznij pracę")
        btn_ok.setFixedHeight(40)
        btn_ok.setStyleSheet("background-color: #4CAF50; color: white; font-weight: bold; border-radius: 4px;")
        btn_ok.clicked.connect(self.accept)
        layout.addWidget(btn_ok)

    def is_checked(self):
        return self.chk_dont_show.isChecked()

class PatternHolesPanel(QtGui.QWidget): 
    def __init__(self): 
        super(PatternHolesPanel, self).__init__() 
        self.target_face = None 
        self.target_object = None 
        self.origin = None; self.u = None; self.v = None; self.n = None 
        self.preview_enabled = True 

        self.preview_timer = QtCore.QTimer() 
        self.preview_timer.setSingleShot(True) 
        self.preview_timer.setInterval(150) 
        self.preview_timer.timeout.connect(self.update_preview_geometry) 

        self.blink_timer = QtCore.QTimer() 
        self.blink_timer.setInterval(100) 
        self.blink_timer.timeout.connect(self.blink_button_tick) 
        self.blink_counter = 0 

        self.setStyleSheet(""" 
            QWidget { background-color: #333333; color: #e0e0e0; font-family: sans-serif; font-size: 14px; } 
            QGroupBox { border: 1px solid #555555; margin-top: 10px; border-radius: 4px; padding-top: 15px; } 
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top center; padding: 0 5px; color: #4CAF50; background-color: #333333; } 
            QPushButton { border: 1px solid #666666; padding: 6px; border-radius: 4px; color: #ffffff; background-color: #444444; } 
            QPushButton:hover { border-color: #4CAF50; } 
            QComboBox, QDoubleSpinBox, QCheckBox { background-color: #222222; border: 1px solid #555555; padding: 4px; color: #ffffff; } 
        """) 

        self.initUI() 
        self.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint) 

    def initUI(self): 
        self.setWindowTitle("Pattern Holes v0.3.19") 
        self.setMinimumWidth(400) 
        self.resize(450, 600) 
        
        main_layout = QtGui.QVBoxLayout() 

        gb_sel = QtGui.QGroupBox("1. Wybór ściany") 
        sel_layout = QtGui.QVBoxLayout() 
        self.btn_sel = QtGui.QPushButton("Pobierz zaznaczoną ścianę") 
        self.btn_sel.setFixedHeight(40) 
        self.btn_sel.clicked.connect(self.start_selection_blink) 
        sel_layout.addWidget(self.btn_sel) 
        gb_sel.setLayout(sel_layout) 
        main_layout.addWidget(gb_sel) 

        self.btn_preview_toggle = QtGui.QPushButton("Podgląd: WŁĄCZONY") 
        self.btn_preview_toggle.setFixedHeight(30) 
        self.btn_preview_toggle.setStyleSheet("background-color: #2e7d32; font-weight: bold;") 
        self.btn_preview_toggle.clicked.connect(self.toggle_preview_state) 
        main_layout.addWidget(self.btn_preview_toggle) 

        gb_pat = QtGui.QGroupBox("3. Parametry wzoru") 
        grid = QtGui.QGridLayout() 
        
        self.combo_type = QtGui.QComboBox() 
        self.combo_type.addItems(["Heksagony", "Kwadraty", "Okręgi", "Romby", "Fasolki", "Trójkąty"]) 
        self.combo_type.currentIndexChanged.connect(self.trigger_update) 
        grid.addWidget(QtGui.QLabel("Kształt:"), 0, 0) 
        grid.addWidget(self.combo_type, 0, 1) 

        def make_spin(val): 
            sb = QtGui.QDoubleSpinBox() 
            sb.setRange(0.01, 1000.0); sb.setValue(val); sb.setSingleStep(0.5); sb.setSuffix(" mm") 
            sb.valueChanged.connect(self.trigger_update) 
            return sb 

        self.sb_size = make_spin(5.0) 
        grid.addWidget(QtGui.QLabel("Rozmiar:"), 1, 0) 
        grid.addWidget(self.sb_size, 1, 1) 

        self.sb_gap = make_spin(1.0) 
        grid.addWidget(QtGui.QLabel("Odstęp (Gap):"), 2, 0) 
        grid.addWidget(self.sb_gap, 2, 1) 

        self.sb_border = make_spin(3.0) 
        grid.addWidget(QtGui.QLabel("Ramka:"), 3, 0) 
        grid.addWidget(self.sb_border, 3, 1) 

        self.chk_horizontal = QtGui.QCheckBox("Fasolki poziomo") 
        self.chk_horizontal.setChecked(True) 
        self.chk_horizontal.stateChanged.connect(self.trigger_update) 
        grid.addWidget(self.chk_horizontal, 4, 1) 

        gb_pat.setLayout(grid) 
        main_layout.addWidget(gb_pat) 

        gb_op = QtGui.QGroupBox("4. Wykonanie") 
        op_layout = QtGui.QGridLayout() 
        self.sb_depth = make_spin(3.0) 
        op_layout.addWidget(QtGui.QLabel("Głębokość:"), 0, 0) 
        op_layout.addWidget(self.sb_depth, 0, 1) 
        gb_op.setLayout(op_layout) 
        main_layout.addWidget(gb_op) 

        btn_box = QtGui.QHBoxLayout() 
        self.btn_run = QtGui.QPushButton("GENERUJ WYCIĘCIE") 
        self.btn_run.setFixedHeight(45) 
        self.btn_run.setStyleSheet("background-color: #d32f2f; font-weight: bold; color: white;") 
        self.btn_run.clicked.connect(self.run_generation) 
        
        self.btn_close = QtGui.QPushButton("Zamknij Makro") 
        self.btn_close.setFixedHeight(45) 
        self.btn_close.clicked.connect(self.close) 

        btn_box.addWidget(self.btn_run); btn_box.addWidget(self.btn_close) 
        main_layout.addLayout(btn_box) 
        main_layout.addStretch() 
        self.setLayout(main_layout) 

    def start_selection_blink(self): 
        self.blink_counter = 0; self.blink_timer.start() 

    def blink_button_tick(self): 
        self.blink_counter += 1 
        self.btn_sel.setStyleSheet("background-color: #2196F3;" if self.blink_counter % 2 else "") 
        if self.blink_counter >= 4: 
            self.blink_timer.stop(); self.get_selection() 

    def get_selection(self): 
        sel = Gui.Selection.getSelectionEx() 
        if not sel: return
        target = sel[-1]
        if not target.SubObjects or not isinstance(target.SubObjects[-1], Part.Face): return 
        f = target.SubObjects[-1]
        try: 
            self.n = f.normalAt(0,0); self.n.normalize() 
            self.origin = f.CenterOfMass 
            ref = App.Vector(1,0,0) if abs(self.n.dot(App.Vector(1,0,0))) < 0.9 else App.Vector(0,1,0) 
            self.u = ref.cross(self.n); self.u.normalize() 
            self.v = self.n.cross(self.u); self.v.normalize() 
            self.target_face, self.target_object = f, target.Object 
            self.btn_sel.setText(f"Wybrano: {self.target_object.Label}"); self.btn_sel.setStyleSheet("background-color: #43A047; font-weight: bold;") 
            Gui.Selection.clearSelection()
            self.trigger_update() 
        except: pass 

    def generate_pattern_shapes(self, idx, xmin, xmax, ymin, ymax, d, gap): 
        out = [] 
        is_horiz = self.chk_horizontal.isChecked() 
        if idx == 0: sx = d + gap; sy = sx * 0.866025
        elif idx == 1 or idx == 2: sx = sy = d + gap
        elif idx == 3: sx = d + gap; sy = (d + gap) / 2.0
        elif idx == 4:
            w = d * 0.4
            sx = (d + gap) if is_horiz else (w + gap); sy = (w + gap) if is_horiz else (d + gap)
        elif idx == 5: sx = d + gap; sy = d * 0.866025 + gap
        else: sx = sy = d + gap
        
        cols, rows = int((xmax-xmin)/sx)+6, int((ymax-ymin)/sy)+6
        for r in range(-3, rows): 
            for c in range(-3, cols): 
                cx, cy = xmin + c*sx, ymin + r*sy 
                if r % 2 == 1: cx += sx / 2.0 
                if idx == 0:
                    rad = d / math.sqrt(3)
                    pts = [App.Vector(cx + rad*math.cos(a), cy + rad*math.sin(a), 0) for a in [math.radians(60*i+30) for i in range(7)]]
                    out.append(Part.makePolygon(pts))
                elif idx == 1:
                    s = d/2.0
                    out.append(Part.makePolygon([App.Vector(cx-s,cy-s,0), App.Vector(cx+s,cy-s,0), App.Vector(cx+s,cy+s,0), App.Vector(cx-s,cy+s,0), App.Vector(cx-s,cy-s,0)]))
                elif idx == 2:
                    out.append(Part.makeCircle(d/2.0, App.Vector(cx, cy, 0)))
                elif idx == 3:
                    h = d/2.0
                    out.append(Part.makePolygon([App.Vector(cx,cy-h,0), App.Vector(cx+h,cy,0), App.Vector(cx,cy+h,0), App.Vector(cx-h,cy,0), App.Vector(cx,cy-h,0)]))
                elif idx == 4:
                    w = d*0.4; r_s, l = w/2.0, (d-w)/2.0
                    if is_horiz:
                        e1 = Part.makeLine(App.Vector(cx-l, cy+r_s, 0), App.Vector(cx+l, cy+r_s, 0))
                        e2 = Part.Arc(App.Vector(cx+l, cy+r_s, 0), App.Vector(cx+l+r_s, cy, 0), App.Vector(cx+l, cy-r_s, 0)).toShape()
                        e3 = Part.makeLine(App.Vector(cx+l, cy-r_s, 0), App.Vector(cx-l, cy-r_s, 0))
                        e4 = Part.Arc(App.Vector(cx-l, cy-r_s, 0), App.Vector(cx-l-r_s, cy, 0), App.Vector(cx-l, cy+r_s, 0)).toShape()
                    else:
                        e1 = Part.Arc(App.Vector(cx-r_s, cy+l, 0), App.Vector(cx, cy+l+r_s, 0), App.Vector(cx+r_s, cy+l, 0)).toShape()
                        e2 = Part.makeLine(App.Vector(cx+r_s, cy+l, 0), App.Vector(cx+r_s, cy-l, 0))
                        e3 = Part.Arc(App.Vector(cx+r_s, cy-l, 0), App.Vector(cx, cy-l-r_s, 0), App.Vector(cx-r_s, cy-l, 0)).toShape()
                        e4 = Part.makeLine(App.Vector(cx-r_s, cy-l, 0), App.Vector(cx-r_s, cy+l, 0))
                    out.append(Part.Wire([e1,e2,e3,e4]))
                elif idx == 5:
                    h = d*0.866; off = h/3.0
                    p1, p2, p3 = (App.Vector(cx,cy+h-off,0), App.Vector(cx+d/2,cy-off,0), App.Vector(cx-d/2,cy-off,0))
                    if r%2==1: p1.y, p2.y, p3.y = cy-h+off, cy+off, cy+off
                    out.append(Part.makePolygon([p1,p2,p3,p1]))
        return out 

    def get_final_compound(self, work_face):
        idx = self.combo_type.currentIndex()
        xs, ys = [], []
        for vtx in work_face.Vertexes:
            vec = vtx.Point.sub(self.origin)
            xs.append(vec.dot(self.u)); ys.append(vec.dot(self.v))
        xmin, xmax, ymin, ymax = min(xs), max(xs), min(ys), max(ys)
        raw = self.generate_pattern_shapes(idx, xmin, xmax, ymin, ymax, self.sb_size.value(), self.sb_gap.value())
        pl = App.Placement(self.origin, App.Rotation(self.u, self.v, self.n))
        valid = []
        for s in raw:
            f = make_face_from_shape(s)
            if f:
                f.Placement = pl
                try:
                    c = f.common(work_face)
                    if c.Area > 0.001: valid.append(c)
                except: pass
        return Part.makeCompound(valid) if valid else None

    def trigger_update(self): 
        if self.preview_enabled and self.target_face: self.preview_timer.start() 

    def toggle_preview_state(self): 
        self.preview_enabled = not self.preview_enabled 
        self.btn_preview_toggle.setText("Podgląd: WŁĄCZONY" if self.preview_enabled else "Podgląd: WYŁĄCZONY") 
        if not self.preview_enabled: self.remove_preview_object() 
        else: self.trigger_update() 

    def remove_preview_object(self): 
        if App.ActiveDocument and App.ActiveDocument.getObject(PREVIEW_OBJ_NAME): 
            App.ActiveDocument.removeObject(PREVIEW_OBJ_NAME) 

    def update_preview_geometry(self): 
        if not self.target_face: return 
        self.remove_preview_object() 
        try: 
            border = self.sb_border.value() 
            work_face = self.target_face.makeOffset2D(-border).Faces[0] if border > 0 else self.target_face 
            cp = self.get_final_compound(work_face) 
            if cp: 
                po = App.ActiveDocument.addObject("Part::Feature", PREVIEW_OBJ_NAME) 
                po.Shape = cp.extrude(self.n.multiply(1.0)).fuse(cp.extrude(self.n.multiply(-1.0))) 
                po.ViewObject.ShapeColor = (1.0, 0.0, 0.0); po.ViewObject.Transparency = 40 
        except: pass 

    def run_generation(self): 
        if not self.target_face: return 
        self.remove_preview_object() 
        doc = App.ActiveDocument 
        doc.openTransaction("PatternHoles") 
        try: 
            border, depth = self.sb_border.value(), self.sb_depth.value()
            work_face = self.target_face.makeOffset2D(-border).Faces[0] if border > 0 else self.target_face 
            cp = self.get_final_compound(work_face) 
            if cp: 
                cutter = cp.extrude(self.n.multiply(depth + 1.0)).fuse(cp.extrude(self.n.multiply(-(depth + 1.0)))) 
                res = self.target_object.Shape.cut(cutter) 
                new_obj = doc.addObject("Part::Feature", "Patterned_" + self.target_object.Label) 
                new_obj.Shape = res; self.target_object.Visibility = False 
                doc.commitTransaction(); doc.recompute() 
                self.btn_sel.setText("Pobierz kolejną ścianę"); self.btn_sel.setStyleSheet("background-color: #444444;") 
                self.target_face = None; Gui.Selection.clearSelection() 
            else: doc.abortTransaction() 
        except Exception as e: 
            doc.abortTransaction(); QtGui.QMessageBox.critical(self, "Błąd", str(e)) 

def main(): 
    global pattern_macro_window 
    
    # Zarządzanie parametrami (Ustawienia użytkownika)
    params = App.ParamGet("User parameter:BaseApp/Preferences/Macros/PatternHoles")
    show_welcome = params.GetBool("ShowWelcome", True)
    
    if show_welcome:
        welcome = WelcomeDialog()
        if welcome.exec_():
            if welcome.is_checked():
                params.SetBool("ShowWelcome", False)

    if pattern_macro_window: 
        try: pattern_macro_window.close() 
        except: pass 
    pattern_macro_window = PatternHolesPanel() 
    pattern_macro_window.show() 

if __name__ == "__main__": 
    main()